package gjkr

import (
	"fmt"

	"threshold.network/roast/ephemeral"
)

// generateEphemeralKeyPair takes the group member list and generates an
// ephemeral ECDH keypair for every other group member. Generated public
// ephemeral keys are broadcasted within the group.
//
// See Phase 1 of the protocol specification.
func (m *ephemeralKeyPairGeneratingMember) generateEphemeralKeyPair() (
	*ephemeralPublicKeyMessage,
	error,
) {
	ephemeralKeys := make(map[memberIndex]*ephemeral.PublicKey)

	// Calculate ephemeral key pair for every other group member
	for _, member := range m.group.allMemberIndexes {
		if member == m.memberIndex {
			// donâ€™t actually generate a key with ourselves
			continue
		}

		ephemeralKeyPair, err := ephemeral.GenerateKeyPair()
		if err != nil {
			return nil, err
		}

		// save the generated ephemeral key to our state
		m.ephemeralKeyPairs[member] = ephemeralKeyPair

		// store the public key to the map for the message
		ephemeralKeys[member] = ephemeralKeyPair.PublicKey
	}

	return &ephemeralPublicKeyMessage{
		senderIndex:         m.memberIndex,
		ephemeralPublicKeys: ephemeralKeys,
	}, nil
}

// generateSymmetricKeys attempts to generate symmetric keys for all remote group
// members via ECDH. It generates this symmetric key for each remote group member
// by doing an ECDH between the ephemeral private key generated for a remote
// group member, and the public key for this member, generated and broadcasted by
// the remote group member.
//
// See Phase 2 of the protocol specification.
func (m *symmetricKeyGeneratingMember) generateSymmetricKeys(
	ephemeralPubKeyMessages []*ephemeralPublicKeyMessage,
) error {
	for _, ephemeralPubKeyMessage := range deduplicateBySender(
		ephemeralPubKeyMessages,
	) {
		otherMember := ephemeralPubKeyMessage.senderIndex

		if !m.isValidEphemeralPublicKeyMessage(ephemeralPubKeyMessage) {
			m.logger.Warn(
				"other member disqualified for sending invalid "+
					"ephemeral public key message",
				"thisMember", m.memberIndex,
				"otherMember", otherMember,
			)
			m.group.markMemberAsDisqualified(otherMember)
			continue
		}

		err := m.evidenceLog.putEphemeralPublicKeyMessage(ephemeralPubKeyMessage)
		if err != nil {
			m.logger.Error(
				"could not put ephemeral key message from other member "+
					"to the evidence log",
				"thisMember", m.memberIndex,
				"otherMember", otherMember,
				"error", err,
			)
		}

		// Find the ephemeral key pair generated by this group member for
		// the other group member.
		ephemeralKeyPair, ok := m.ephemeralKeyPairs[otherMember]
		if !ok {
			return fmt.Errorf(
				"ephemeral key pair does not exist for member %v",
				otherMember,
			)
		}

		// Get the ephemeral private key generated by this group member for
		// the other group member.
		thisMemberEphemeralPrivateKey := ephemeralKeyPair.PrivateKey

		// Get the ephemeral public key broadcasted by the other group member,
		// which was intended for this group member.
		otherMemberEphemeralPublicKey := ephemeralPubKeyMessage.ephemeralPublicKeys[m.memberIndex]

		// Create symmetric key for the current group member and the other
		// group member by ECDH'ing the public and private key.
		symmetricKey := thisMemberEphemeralPrivateKey.Ecdh(
			otherMemberEphemeralPublicKey,
		)
		m.symmetricKeys[otherMember] = symmetricKey
	}

	return nil
}

// isValidEphemeralPublicKeyMessage validates a given EphemeralPublicKeyMessage.
// Message is considered valid if it contains ephemeral public keys for
// all other group members.
func (m *symmetricKeyGeneratingMember) isValidEphemeralPublicKeyMessage(
	message *ephemeralPublicKeyMessage,
) bool {
	for _, index := range m.group.allMemberIndexes {
		if index == message.senderIndex {
			// Message contains ephemeral public keys only for other group members
			continue
		}

		if _, ok := message.ephemeralPublicKeys[index]; !ok {
			m.logger.Warn(
				"ephemeral public key message from other member "+
					"does not contain required public key",
				"thisMember", m.memberIndex,
				"otherMember", message.senderIndex,
				"missingPubKeyMember", index,
			)
			return false
		}
	}

	return true
}

// deduplicateBySender removes duplicated items for the given sender.
// It always takes the first item that occurs for the given sender
// and ignores the subsequent ones.
func deduplicateBySender[T interface{ senderIdx() memberIndex }](
	list []T,
) []T {
	senders := make(map[memberIndex]bool)
	result := make([]T, 0)

	for _, item := range list {
		if _, exists := senders[item.senderIdx()]; !exists {
			senders[item.senderIdx()] = true
			result = append(result, item)
		}
	}

	return result
}
